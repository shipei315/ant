函数式接口本身还是一个接口，但是是一种特殊类型的接口，这种类型的接口称之为SAM (Single abstract method)。
最终造成的效果是以其为参数的方法可以使用lambda表达式构造该参数。反过来说，如果调用某方法时可以传入lambda表达式作为参数的话则该参数一定是函数式接口
，该参数的类型一定被@FunctionalInterface修饰或者是既成事实上的函数式接口（符合SAM约定）。
加上@FunctionalInterface注释之后会强制javac检查该接口是否符合函数接口的标准（如果不止包含一个方法则报错）

注意：所谓的SAM 指的是只允许一个抽象方法，也只有一个抽象方法需要被实现。但是也有几个例外：
默认方法和静态方法并不影响SAM接口成为函数式接口。另外在Object类中存在的方法也不影响。

默认方法即在方法前加上default关键字，该方法可以有具体实现，添加该方法的主要目的是为了向前兼容。
方法重写的规则子接口中的方法覆盖父接口中的方法，类中重写的方法胜出（避免之前在自有类中的方法被覆盖）。
对于多重继承如果没有明确地在子类中写明要使用哪个方法将会报错。

为什么会产生静态方法？
本来来说类是放置工具类的好地方，但是往往是一个类中包含了许多工具方法且这些工具方法并不是属于某个具体类的。
如果一个方法中有充分的语义原因和某个概念相关，那么就应该将该方法和相关类和接口组织在一起。而不是在另外一个单独的工具类中。
这样有助于更好的组织代码，更好的查阅和使用。
如Stream中产生流的方法。